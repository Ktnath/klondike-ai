#!/usr/bin/env python3
"""Inspect a dataset of expert moves.

This utility focuses on ``.npz`` files generated by the project.  It extracts
the ``actions`` (integer indices), optional ``intentions`` (texts) and optional
``moves`` (textual representation of a move) arrays.  The script then reports
statistics and performs a few consistency checks:

* frequency of each action and intention,
* every action index must be strictly positive,
* the round‑trip move → index → move must hold.

Example
-------
``python dataset_stats.py --input data/expert_dataset.npz``
"""

from __future__ import annotations

import argparse
from collections import Counter
from typing import Iterable, Optional

import numpy as np
from tqdm import tqdm

from klondike_core import move_index, move_from_index


def analyse(path: str) -> None:
    """Read ``path`` and print various statistics."""

    try:
        data = np.load(path, allow_pickle=True)
    except Exception as exc:  # pragma: no cover - depends on user input
        print(f"❌ Failed to load NPZ file '{path}': {exc}")
        return

    actions = data.get("actions")
    intentions = data.get("intentions")
    moves = data.get("moves")

    if actions is None:
        print("⚠️  Dataset does not contain an 'actions' array")
        return

    total = int(len(actions))
    action_counts = Counter(actions.tolist())
    invalid_actions = int(np.sum(actions <= 0))

    intention_counts: Counter[str] = Counter()
    invalid_intentions = 0
    if intentions is not None:
        # ``None`` and empty strings are considered invalid intentions
        valid_intentions = [i for i in intentions.tolist() if i]
        intention_counts.update(valid_intentions)
        invalid_intentions = len(intentions) - len(valid_intentions)
    else:
        print("⚠️  No 'intentions' array found")

    mismatches: list[tuple[int, str, int, int, Optional[str]]] = []
    if moves is not None:
        for idx, move in enumerate(tqdm(moves, desc="Checking moves")):
            idx_from_move = move_index(move)
            back_to_move = move_from_index(idx_from_move)
            action_val = int(actions[idx])
            if (
                idx_from_move <= 0
                or action_val != idx_from_move
                or back_to_move != move
            ):
                mismatches.append((idx, move, action_val, idx_from_move, back_to_move))
    else:
        print("⚠️  No 'moves' array found")

    # --- Frequencies -----------------------------------------------------
    print("\nAction frequencies:")
    for act, count in action_counts.most_common():
        print(f"  {act}: {count}")

    if intention_counts:
        print("\nIntention frequencies:")
        for intent, count in intention_counts.most_common():
            print(f"  {intent!r}: {count}")

    if mismatches:
        print("\n❌ Inconsistent moves detected:")
        for i, mv, act, idx_mv, back in mismatches[:10]:
            print(
                f"  sample {i}: move={mv!r}, action={act}, "
                f"move_index={idx_mv}, move_from_index={back!r}"
            )

    # --- Summary --------------------------------------------------------
    print("\nSummary:")
    print(f"  Total moves: {total}")
    print(f"  Unique actions: {len(action_counts)}")
    if intentions is not None:
        print(f"  Unique intentions: {len(intention_counts)}")
    print(f"  Invalid actions (<=0): {invalid_actions}")
    if intentions is not None:
        print(f"  Invalid intentions: {invalid_intentions}")
    print(f"  Round-trip mismatches: {len(mismatches)}")


def main(argv: Optional[Iterable[str]] = None) -> None:
    parser = argparse.ArgumentParser(
        description="Inspect an expert dataset stored as NPZ"
    )
    parser.add_argument(
        "--input",
        type=str,
        default="data/expert_dataset.npz",
        help="Path to .npz dataset file",
    )
    args = parser.parse_args(list(argv) if argv is not None else None)

    analyse(args.input)


if __name__ == "__main__":
    main()

